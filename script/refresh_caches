#!/usr/bin/env ruby
# frozen_string_literal: true

#  USAGE::
#
#    script/refresh_caches
#
#  DESCRIPTION::
#
#  This is a nightly cronjob that checks to make sure the classification string
#  of each infrageneric taxon is the same as the classification string for the
#  parent genus.  It checks for missing genera while it's at it.  It prints out
#  a line for each taxon it finds that it has to fix.
#
#  It also makes sure the classification section of the default description
#  matches the classification string cached in the name, preferring the
#  description version above genus, and preferring the cached version below
#  genus.
#
################################################################################

require(File.expand_path("../config/boot.rb", __dir__))
require(File.expand_path("../config/environment.rb", __dir__))

# -----------------------------------------------------------------------------

# I was going to put this in Name, but it's such a specialized and complicated
# operation that I decided I'd rather not pollute the main code with it unless
# other folks disagree strongly with me. -JPH 20210812
def propagate_generic_classifications(dry_run: false)
  fixes = []
  accepted_names = build_accepted_names_lookup_table
  classifications = accepted_generic_classification_strings
  Name.select(:id, :synonym_id, :text_name, :classification).
    where(rank: 0..Name.ranks[:Genus] - 1).
    each do |id, synonym_id, text_name, classification|
      genus = (accepted_names[synonym_id] || text_name).split.first
      next if (classification = clean(classification)) == classifications[genus]

      fixes << [id, text_name, classification, classifications[genus]]
    end
  execute_fixes(fixes, dry_run)
end

def clean(classification)
  classification.strip if classification.present?
end

def build_accepted_names_lookup_table
  accepted_names = {}
  Name.select(:synonym_id, :text_name).
    where(rank: 0..Name.ranks[:Genus], deprecated: false).
    where.not(synonym_id: nil).
    each do |synonym_id, text_name|
      accepted_names[synonym_id] = text_name
    end
  accepted_names
end

def accepted_generic_classification_strings
  classifications = {}
  Name.select(:text_name, :classification).
    where(rank: Name.ranks[:Genus], deprecated: false).
    where("author NOT LIKE 'sensu lato%'").
    each do |text_name, classification|
      next if classification.blank?

      if classifications[text_name].present?
        warn("Multiple accepted non-sensu lato genera for #{text_name}!")
      else
        classifications[text_name] = classification.strip
      end
    end
  classifications
end

def hash_of_names_with_observations
  Hash[
    Observation.distinct.pluck(:text_name).collect do |text_name|
      [text_name, true]
    end
  ]
end

def execute_fixes(fixes, dry_run)
  bundles = {}
  used_names = hash_of_names_with_observations
  msgs = fixes.map do |id, text_name, old_class, new_class|
    bundles[new_class] = [] if bundles[new_class].blank?
    bundles[new_class] << id
    next unless used_names[text_name]

    if new_class.blank?
      "Stripping classification from #{text_name}"
    elsif old_class.blank?
      "Filling in classification for #{text_name}"
    else
      "Fixing classification of #{text_name}: #{changes(old_class, new_class)}"
    end
  end
  msgs.reject(&:nil?) + execute_bundled_fixes(bundles, dry_run)
end

def execute_bundled_fixes(bundles, dry_run)
  msgs = []
  bundles.each do |classification, ids|
    next if classification.blank?

    msgs << "Setting classifications for #{ids.join(",")}"
    next if dry_run

    # Deliberately skip validations
    # rubocop:disable Rails/SkipsModelValidations
    Name.where(id: ids).update_all(classification: classification)
    # rubocop:enable Rails/SkipsModelValidations
  end
  msgs
end

def changes(old_classification, new_classification)
  msgs = []
  Name.all_ranks.each do |rank|
    old_name = parse_classification(old_classification, rank)
    new_name = parse_classification(new_classification, rank)
    msgs << "#{old_name} => #{new_name}" if old_name != new_name
  end
  msgs.join(", ")
end

def parse_classification(str, rank)
  match = str.to_s.match(/#{rank}: _([^_]+)_/)
  match ? match[1] : "-"
end

# -----------------------------------------------------------------------------

dry_run = false
ARGV.each do |flag|
  case flag
  when "-n", "--dry-run"
    dry_run = true
  else
    puts("USAGE: script/refresh_caches [-n|--dry-run]")
    exit(1)
  end
end

msgs = if dry_run
         propagate_generic_classifications(dry_run: true)
       else
         Synonym.make_sure_all_referenced_synonyms_exist +
           Name.fix_self_referential_misspellings +
           Name.make_sure_names_are_bolded_correctly +
           Name.refresh_classification_caches +
           propagate_generic_classifications +
           Observation.make_sure_no_observations_are_misspelled +
           Observation.refresh_content_filter_caches
       end
warn(msgs.join("\n")) if msgs.any?

exit(0)
