# frozen_string_literal: true

require("test_helper")

module SpeciesLists
  class WriteInControllerTest < FunctionalTestCase
    def test_create_species_list_member_notes_areas
      # Prove that only member_notes textarea is Other
      # for user without notes template
      user = users(:rolf)
      login(user.login)
      get(:new, params: { id: species_lists(:first_species_list).id })
      assert_page_has_correct_notes_areas(
        klass: SpeciesList,
        expect_areas: { Observation.other_notes_key => "" }
      )

      # Prove that member_notes textareas are those for template plus Other
      # for user with notes template
      user = users(:notes_templater)
      login(user.login)
      get(:new, params: { id: species_lists(:first_species_list).id })
      assert_page_has_correct_notes_areas(
        klass: SpeciesList,
        expect_areas: { Cap: "", Nearby_trees: "", odor: "",
                        Observation.other_notes_key => "" }
      )
    end

    # <name> = <name> shouldn't work in construct_species_list
    def test_construct_species_list_synonym
      species_list = species_lists(:first_species_list)
      name = names(:macrolepiota_rachodes)
      synonym_name = names(:lepiota_rachodes)
      assert_not(synonym_name.deprecated)
      assert_nil(synonym_name.synonym_id)
      params = {
        id: species_list.id,
        list: { members: "#{name.text_name} = #{synonym_name.text_name}" },
      }
      login("rolf")
      contrib = rolf.contribution
      post(:create, params: params)
      assert_equal(contrib, rolf.reload.contribution)
      assert_not(synonym_name.reload.deprecated)
      assert_nil(synonym_name.synonym_id)
    end

    def test_construct_species_list_nonalpha_multiple
      # First try creating it with ambiguous name "Warnerbros bugs-bunny".

      # There are two such names with authors One and Two, respectively.
      # We don't know which Name has the lower autogenerated id.  So create a
      # variable so we can relate Name to Author
      species_list = species_lists(:first_species_list)
      bugs_names = Name.where(text_name: "Warnerbros bugs-bunny")

      params = {
        id: species_list.id,
        list: { members: "\n Warnerbros  bugs-bunny " }
      }
      login("rolf")
      contrib = rolf.contribution
      post(:create, params: params)
      assert_equal(contrib, rolf.reload.contribution)
      assert_equal("Warnerbros bugs-bunny",
                   @controller.instance_variable_get(:@list_members))
      assert_equal([], @controller.instance_variable_get(:@new_names))
      assert_equal([bugs_names.first],
                   @controller.instance_variable_get(:@multiple_names))
      assert_equal([], @controller.instance_variable_get(:@deprecated_names))

      # Now re-post, having selected the other Bugs Bunny name.
      params = {
        id: species_list.id,
        list: { members: "Warnerbros bugs-bunny\r\n" },
        chosen_multiple_names: { bugs_names.first.id.to_s =>
                                 bugs_names.second.id }
      }
      post(:create, params: params)
      contrib += OBSERVATION_SCORE
      assert_redirected_to(species_list_path(species_list.id))
      assert_equal(contrib, rolf.reload.contribution)
      assert(species_list.name_included?(bugs_names.second))
    end

    def test_add_observations_with_member_fields
      spl = species_lists(:first_species_list)
      contrib = rolf.contribution + OBSERVATION_SCORE
      params = {
        list: { members: names(:coprinus_comatus).text_name },
        member: {
          vote: Vote.minimum_vote,
          notes: { Observation.other_notes_key => "member notes" },
          lat: "12 34 56 N",
          lng: "78 9 12 W",
          alt: "345 ft",
          is_collection_location: "1",
          specimen: "1"
        },
        id: spl.id
      }
      post_requires_login(:create, params)

      assert_redirected_to(species_list_path(spl.id))
      assert_equal(contrib, rolf.reload.contribution)
      assert_not_nil(spl)
      assert(spl.name_included?(names(:coprinus_comatus)))
      obs = spl.observations.first
      assert_equal(Vote.minimum_vote, obs.namings.first.votes.first.value)
      assert_equal([Observation.other_notes_key], obs.notes.keys)
      assert_equal(obs.notes[Observation.other_notes_key], "member notes")
      assert_equal(12.5822, obs.lat)
      assert_equal(-78.1533, obs.lng)
      assert_equal(105, obs.alt)
      assert_equal(true, obs.is_collection_location)
      assert_equal(true, obs.specimen)
    end

    # Rather than repeat everything done for update_species, this construct
    # species just does a bit of everything:
    #   Written in:
    #     Lactarius subalpinus (deprecated, approved)
    #     Amanita baccata      (ambiguous, checked Arora in radio boxes)
    #     New name             (new, approved from previous post)
    # Should result in the following list:
    #   Lactarius subalpinus
    #   Amanita baccata Arora
    #   New name
    #   Agaricus campestris
    #   Lactarius alpinus
    #   (but *NOT* L. alpingenes)
    def test_construct_species_list_extravaganza
      spl = species_lists(:first_species_list)
      deprecated_name = names(:lactarius_subalpinus)
      list_members = [deprecated_name.text_name]
      multiple_name = names(:amanita_baccata_arora)
      list_members.push(multiple_name.text_name)
      new_name_str = "New name"
      list_members.push(new_name_str)
      assert_nil(Name.find_by(text_name: new_name_str))
      deprecated_alt_name = names(:lactarius_alpigenes)
      list_members.push(deprecated_alt_name.text_name)
      approved_name = names(:lactarius_alpinus)

      params = {
        id: spl.id,
        list: { members: list_members.join("\r\n") },
        member: { notes: Observation.no_notes },
      }
      params[:approved_names] = new_name_str
      params[:chosen_multiple_names] =
        { multiple_name.id.to_s => multiple_name.id.to_s }
      params[:chosen_approved_names] =
        { deprecated_alt_name.id.to_s => approved_name.id.to_s }
      params[:approved_deprecated_names] = [
        deprecated_name.id.to_s, deprecated_alt_name.id.to_s
      ].join("\r\n")

      login("rolf")
      contrib = rolf.contribution + NAME_SCORE * 2 + OBSERVATION_SCORE * 4
      post(:create, params: params)

      assert_redirected_to(species_list_path(spl.id))
      # Creates "New" and "New name", spl, and five obs/naming/splentries.
      assert_equal(contrib, rolf.reload.contribution)
      assert(spl.name_included?(deprecated_name))
      assert(spl.name_included?(multiple_name))
      assert(spl.name_included?(Name.find_by(text_name: new_name_str)))
      assert_not(spl.name_included?(deprecated_alt_name))
      assert(spl.name_included?(approved_name))
    end

    def test_construct_species_list_existing_genus
      spl = species_lists(:first_species_list)
      contrib = rolf.contribution + OBSERVATION_SCORE
      agaricus = names(:agaricus)
      params = {
        id: spl.id,
        list: { members: "#{agaricus.rank} #{agaricus.text_name}" }
      }
      login("rolf")
      post(:create, params: params)

      assert_redirected_to(species_list_path(spl.id))
      assert_equal(contrib, rolf.reload.contribution)
      assert_not_nil(spl)
      assert(spl.name_included?(agaricus))
    end

    def test_construct_species_list_new_family
      spl = species_lists(:first_species_list)
      contrib = rolf.contribution + NAME_SCORE + OBSERVATION_SCORE
      rank = "Family"
      new_name_str = "Lecideaceae"
      new_list_str = "#{rank} #{new_name_str}"
      assert_nil(Name.find_by(text_name: new_name_str))
      params = {
        id: spl.id,
        list: { members: new_list_str },
        approved_names: new_list_str
      }
      login("rolf")
      post(:create, params: params)

      assert_redirected_to(species_list_path(spl.id))
      # Creates Lecideaceae, spl, and obs/naming/splentry.
      assert_equal(contrib, rolf.reload.contribution)
      assert_not_nil(spl)
      new_name = Name.find_by(text_name: new_name_str)
      assert_not_nil(new_name)
      assert_equal(rank, new_name.rank)
      assert(spl.name_included?(new_name))
    end

    def test_construct_species_list_junk
      spl = species_lists(:first_species_list)
      contrib = rolf.contribution
      new_name_str = "This is a bunch of junk"
      assert_nil(Name.find_by(text_name: new_name_str))
      params = {
        id: spl.id,
        list: { members: new_name_str },
        member: { notes: Observation.no_notes },
        approved_names: new_name_str
      }
      login("rolf")
      post(:create, params: params)
      assert_equal(contrib, rolf.reload.contribution)
      assert_nil(Name.find_by(text_name: new_name_str))
    end

    def test_construct_species_list_double_space
      spl = species_lists(:first_species_list)
      list_title = "Double Space List"
      new_name_str = "Lactarius rubidus  (Hesler and Smith) Methven"
      params = {
        id: spl.id,
        list: { members: new_name_str },
        member: { notes: Observation.no_notes },
        approved_names: new_name_str.squeeze(" ")
      }
      login("rolf")
      contrib = rolf.contribution + NAME_SCORE + OBSERVATION_SCORE
      post(:create, params: params)

      assert_redirected_to(species_list_path(spl.id))
      # Creating L. rubidus (and spl and obs/splentry/naming).
      assert_equal(contrib, rolf.reload.contribution)
      obs = spl.observations.first
      assert_not_nil(obs)
      assert_not_nil(obs.updated_at)
      name = Name.find_by(search_name: new_name_str.squeeze(" "))
      assert_not_nil(name)
      assert(spl.name_included?(name))
    end

    def test_construct_species_list_rankless_taxon
      spl = species_lists(:first_species_list)
      new_name_str = "Lecideaceae"
      assert_nil(Name.find_by(text_name: new_name_str))
      params = {
        id: spl.id,
        list: { members: new_name_str },
        member: { notes: Observation.no_notes },
        approved_names: new_name_str
      }
      login("rolf")
      contrib = rolf.contribution + NAME_SCORE + OBSERVATION_SCORE
      post(:create, params: params)

      assert_redirected_to(species_list_path(spl.id))
      # Creates Lecideaceae, spl, obs/naming/splentry.
      assert_equal(contrib, rolf.reload.contribution)
      assert_not_nil(spl)
      new_name = Name.find_by(text_name: new_name_str)
      assert_not_nil(new_name)
      assert_equal("Family", new_name.rank)
      assert(spl.name_included?(new_name))
    end

    # ----------------------------
    #  Name lister and reports.
    # ----------------------------

    def test_name_resolution_1
      spl = species_lists(:first_species_list)
      params = {
        id: spl.id,
        member: { notes: Observation.no_notes },
        list: {}
      }
      @request.session[:user_id] = rolf.id

      params[:list][:members] = [
        "Fungi",
        "Agaricus sp",
        "Psalliota sp.",
        '"One"',
        '"Two" sp',
        '"Three" sp.',
        'Agaricus "blah"',
        "Chlorophyllum Author",
        "Lepiota sp Author"
      ].join("\n")
      params[:approved_names] = [
        "Psalliota sp.",
        '"One"',
        '"Two" sp',
        '"Three" sp.',
        'Agaricus "blah"',
        "Chlorophyllum Author",
        "Lepiota sp Author"
      ].join("\r\n")
      post(:create, params: params)
      assert_equal(
        [
          "Fungi",
          "Agaricus",
          "Psalliota",
          "Chlorophyllum Author",
          "Lepiota Author",
          "Gen. 'One'",
          "Gen. 'Two'",
          "Gen. 'Three'",
          "Agaricus sp. 'blah'"
        ].sort,
        assigns(:species_list).observations.map { |x| x.name.search_name }.sort
      )

      # Now verify that the new names can we used with approval
      params = {
        id: species_lists(:another_species_list).id,
        member: { notes: Observation.no_notes },
        list: {}
      }

      params[:list][:members] = [
        "Fungi",
        "Agaricus sp",
        "Psalliota sp.",
        "'One'",
        "'Two' sp",
        "'Three' sp.",
        "Agaricus 'blah'",
        "Chlorophyllum Author",
        "Lepiota sp Author",
        "Lepiota sp. Author"
      ].join("\n")
      params[:approved_names] = [
        "Psalliota sp."
      ].join("\r\n")
      post(:create, params: params)
      assert_equal(
        [
          "Fungi",
          "Agaricus",
          "Psalliota",
          "Chlorophyllum Author",
          "Lepiota Author",
          "Lepiota Author",
          "Gen. 'One'",
          "Gen. 'Two'",
          "Gen. 'Three'",
          "Agaricus sp. 'blah'"
        ].sort,
        assigns(:species_list).observations.map { |x| x.name.search_name }.sort
      )
    end
  end
end
